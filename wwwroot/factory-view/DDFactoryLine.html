<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dishdrawer Production Flow</title>
    <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
    <style>
        body {
            font-family: "Segoe UI", Arial;
            background: #f4f6f9;
            padding: 20px;
        }

        h2 {
            margin-bottom: 12px;
        }

        #cy {
            height: 820px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08);
        }

        .active {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(52,152,219,0.6);
            }

            70% {
                box-shadow: 0 0 0 14px rgba(52,152,219,0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(52,152,219,0);
            }
        }
    </style>
</head>
<body>
    <h2>🏭 DISHDRAWER – Production Flow</h2>
    <div id="cy"></div>

    <script>
        (async () => {
            const urlParams = new URLSearchParams(window.location.search);
            const line = urlParams.get("line") || "DISHDRAWER";
            const serial = urlParams.get("SerialNo");
            if (!serial) { alert("SerialNo is required in URL"); return; }

            let layoutConfig = [], trackHistory = [];

            try {
                const response = await fetch(`/api/FactoryLine/${line}?serial=${encodeURIComponent(serial)}`);
                if (!response.ok) throw new Error(`API returned ${response.status}`);
                const data = await response.json();

                layoutConfig = data.nodes.map(n => ({
                    store: n.store,
                    x: n.positionX,
                    y: n.positionY,
                    label: n.label
                }));

                trackHistory = data.history.filter(h => h.store_location);

            } catch (err) {
                console.error(err);
                alert("Failed to fetch layout or history");
                return;
            }
            const statusColor = {
                P: "#27AE60",  // green
                R: "#3498db",  // soft blue
                D: "#95a5a6"   // grey
            };


            const trackingStatus = {};
            trackHistory.forEach(h => trackingStatus[h.store_location] = h.status);

            const cy = cytoscape({
                container: document.getElementById("cy"),
                layout: { name: "preset" },
                style: [
                    {
                        selector: "node",
                        style: {
                            label: "data(label)",
                            "background-color": "data(color)",
                            shape: "round-rectangle",
                            width: 120,
                            height: 46,
                            "font-size": 12,
                            "text-valign": "center",
                            "text-halign": "center",
                            "overlay-opacity": 0
                        }
                    },
                    {
                        selector: "edge",
                        style: {
                            "curve-style": "bezier",
                            "target-arrow-shape": "triangle",
                            width: 2,
                            "line-color": "#b0b8c2",
                            "target-arrow-color": "#b0b8c2"
                        }
                    }
                ]
            });

            // -----------------------
            // Assign sequential run numbers for green nodes (P) per occurrence
            // -----------------------
            let runNo = 1;
            const nodeRunMap = {}; // we will store arrays for each node

            // Sort history by last_maint ascending
            const sortedHistory = trackHistory
                .filter(h => h.store_location)
                .sort((a, b) => new Date(a.last_maint) - new Date(b.last_maint));

            // Assign run numbers for green nodes per occurrence
            sortedHistory.forEach(h => {
                const nodeId = h.store_location;
                const status = trackingStatus[nodeId] || "D";

                if ((status === "P" || status === "R" || status === "D") && layoutConfig.find(n => n.store === nodeId)) {
                    if (!nodeRunMap[nodeId]) nodeRunMap[nodeId] = [];
                    nodeRunMap[nodeId].push(runNo++);
                }
            });

            // -----------------------
            // Add nodes to Cytoscape
            // -----------------------
            layoutConfig.forEach(cfg => {
                const status = trackingStatus[cfg.store] || "D";
                let label = cfg.label;

                // If node has multiple run numbers, show all separated by comma
                if ((status === "P" || status === "R" || status === "D") && nodeRunMap[cfg.store]) {
                    label = nodeRunMap[cfg.store].map(n => `#${n}`).join(", ") + " " + cfg.label;
                }

                cy.add({
                    data: {
                        id: cfg.store,
                        label: label,
                        color: statusColor[status]
                    },
                    position: { x: cfg.x * 10, y: (100 - cfg.y) * 6 }
                });
            });

            // -----------------------
            // Add edges in chronological order
            // -----------------------
            let lastValidNode = null;
            sortedHistory.forEach(h => {
                const nodeId = h.store_location;
                if (!cy.getElementById(nodeId).empty()) {
                    if (lastValidNode) {
                        cy.add({
                            data: {
                                id: `e${lastValidNode}_${nodeId}`,
                                source: lastValidNode,
                                target: nodeId
                            }
                        });
                    }
                    lastValidNode = nodeId;
                }
            });

            // Highlight last node
            const lastNodeId = sortedHistory.length ? sortedHistory[sortedHistory.length - 1].store_location : null;
            if (lastNodeId && !cy.getElementById(lastNodeId).empty()) {
                cy.getElementById(lastNodeId).addClass("active");
            }

            cy.nodes().lock();

        })();
    </script>
</body>
</html>
